-- WYS community schema
-- Run this in Supabase SQL editor.

create extension if not exists "pgcrypto";

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  display_name text not null default 'User',
  role text not null default 'user' check (role in ('user', 'owner')),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.favorites (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  review_slug text not null,
  created_at timestamptz not null default now(),
  unique (user_id, review_slug)
);

create table if not exists public.user_ratings (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  review_slug text not null,
  rating numeric(3,1) not null check (rating >= 1 and rating <= 10),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (user_id, review_slug)
);

create table if not exists public.review_comments (
  id bigint generated by default as identity primary key,
  review_slug text not null,
  user_id uuid not null references auth.users(id) on delete cascade,
  content text not null check (length(trim(content)) > 0 and length(content) <= 1200),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create table if not exists public.community_posts (
  id bigint generated by default as identity primary key,
  review_slug text not null,
  user_id uuid not null references auth.users(id) on delete cascade,
  content text not null check (length(trim(content)) > 0 and length(content) <= 3000),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (user_id, review_slug)
);

create table if not exists public.community_post_reactions (
  id bigint generated by default as identity primary key,
  post_id bigint not null references public.community_posts(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  reaction text not null check (reaction in ('like', 'dislike')),
  created_at timestamptz not null default now(),
  unique (post_id, user_id)
);

create table if not exists public.community_post_comments (
  id bigint generated by default as identity primary key,
  post_id bigint not null references public.community_posts(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  content text not null check (length(trim(content)) > 0 and length(content) <= 1000),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_favorites_user on public.favorites(user_id);
create index if not exists idx_user_ratings_slug on public.user_ratings(review_slug);
create index if not exists idx_review_comments_slug on public.review_comments(review_slug, created_at desc);
create index if not exists idx_community_posts_slug on public.community_posts(review_slug, updated_at desc);
create index if not exists idx_community_reactions_post on public.community_post_reactions(post_id);
create index if not exists idx_community_comments_post on public.community_post_comments(post_id, created_at desc);

drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at
before update on public.profiles
for each row execute function public.set_updated_at();

drop trigger if exists trg_user_ratings_updated_at on public.user_ratings;
create trigger trg_user_ratings_updated_at
before update on public.user_ratings
for each row execute function public.set_updated_at();

drop trigger if exists trg_review_comments_updated_at on public.review_comments;
create trigger trg_review_comments_updated_at
before update on public.review_comments
for each row execute function public.set_updated_at();

drop trigger if exists trg_community_posts_updated_at on public.community_posts;
create trigger trg_community_posts_updated_at
before update on public.community_posts
for each row execute function public.set_updated_at();

drop trigger if exists trg_community_post_comments_updated_at on public.community_post_comments;
create trigger trg_community_post_comments_updated_at
before update on public.community_post_comments
for each row execute function public.set_updated_at();

create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (id, display_name, role)
  values (
    new.id,
    coalesce(split_part(new.email, '@', 1), 'User'),
    'user'
  )
  on conflict (id) do nothing;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute function public.handle_new_user();

create or replace function public.is_owner()
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'owner'
  );
$$;

alter table public.profiles enable row level security;
alter table public.favorites enable row level security;
alter table public.user_ratings enable row level security;
alter table public.review_comments enable row level security;
alter table public.community_posts enable row level security;
alter table public.community_post_reactions enable row level security;
alter table public.community_post_comments enable row level security;

drop policy if exists "profiles_select_all" on public.profiles;
create policy "profiles_select_all" on public.profiles
for select using (true);

drop policy if exists "profiles_insert_own" on public.profiles;
create policy "profiles_insert_own" on public.profiles
for insert with check (auth.uid() = id);

drop policy if exists "profiles_update_own" on public.profiles;
create policy "profiles_update_own" on public.profiles
for update using (auth.uid() = id)
with check (auth.uid() = id);

drop policy if exists "favorites_select_own" on public.favorites;
create policy "favorites_select_own" on public.favorites
for select using (auth.uid() = user_id);

drop policy if exists "favorites_insert_own" on public.favorites;
create policy "favorites_insert_own" on public.favorites
for insert with check (auth.uid() = user_id);

drop policy if exists "favorites_delete_own" on public.favorites;
create policy "favorites_delete_own" on public.favorites
for delete using (auth.uid() = user_id);

drop policy if exists "ratings_select_all" on public.user_ratings;
create policy "ratings_select_all" on public.user_ratings
for select using (true);

drop policy if exists "ratings_insert_own" on public.user_ratings;
create policy "ratings_insert_own" on public.user_ratings
for insert with check (auth.uid() = user_id);

drop policy if exists "ratings_update_own" on public.user_ratings;
create policy "ratings_update_own" on public.user_ratings
for update using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "comments_select_all" on public.review_comments;
create policy "comments_select_all" on public.review_comments
for select using (true);

drop policy if exists "comments_insert_own" on public.review_comments;
create policy "comments_insert_own" on public.review_comments
for insert with check (auth.uid() = user_id);

drop policy if exists "comments_update_own_or_owner" on public.review_comments;
create policy "comments_update_own_or_owner" on public.review_comments
for update using (auth.uid() = user_id or public.is_owner())
with check (auth.uid() = user_id or public.is_owner());

drop policy if exists "comments_delete_own_or_owner" on public.review_comments;
create policy "comments_delete_own_or_owner" on public.review_comments
for delete using (auth.uid() = user_id or public.is_owner());

drop policy if exists "community_posts_select_all" on public.community_posts;
create policy "community_posts_select_all" on public.community_posts
for select using (true);

drop policy if exists "community_posts_insert_own" on public.community_posts;
create policy "community_posts_insert_own" on public.community_posts
for insert with check (auth.uid() = user_id);

drop policy if exists "community_posts_update_own_or_owner" on public.community_posts;
create policy "community_posts_update_own_or_owner" on public.community_posts
for update using (auth.uid() = user_id or public.is_owner())
with check (auth.uid() = user_id or public.is_owner());

drop policy if exists "community_posts_delete_own_or_owner" on public.community_posts;
create policy "community_posts_delete_own_or_owner" on public.community_posts
for delete using (auth.uid() = user_id or public.is_owner());

drop policy if exists "community_reactions_select_all" on public.community_post_reactions;
create policy "community_reactions_select_all" on public.community_post_reactions
for select using (true);

drop policy if exists "community_reactions_insert_own" on public.community_post_reactions;
create policy "community_reactions_insert_own" on public.community_post_reactions
for insert with check (auth.uid() = user_id);

drop policy if exists "community_reactions_update_own" on public.community_post_reactions;
create policy "community_reactions_update_own" on public.community_post_reactions
for update using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists "community_reactions_delete_own_or_owner" on public.community_post_reactions;
create policy "community_reactions_delete_own_or_owner" on public.community_post_reactions
for delete using (auth.uid() = user_id or public.is_owner());

drop policy if exists "community_post_comments_select_all" on public.community_post_comments;
create policy "community_post_comments_select_all" on public.community_post_comments
for select using (true);

drop policy if exists "community_post_comments_insert_own" on public.community_post_comments;
create policy "community_post_comments_insert_own" on public.community_post_comments
for insert with check (auth.uid() = user_id);

drop policy if exists "community_post_comments_update_own_or_owner" on public.community_post_comments;
create policy "community_post_comments_update_own_or_owner" on public.community_post_comments
for update using (auth.uid() = user_id or public.is_owner())
with check (auth.uid() = user_id or public.is_owner());

drop policy if exists "community_post_comments_delete_own_or_owner" on public.community_post_comments;
create policy "community_post_comments_delete_own_or_owner" on public.community_post_comments
for delete using (auth.uid() = user_id or public.is_owner());

-- Make one account owner after first signup:
-- update public.profiles set role = 'owner' where id = '<YOUR_AUTH_USER_UUID>';
